<?php
/**
 * @file abt.module 
 * Module for controling access by using user->term<-node relationship.
 */

/**
 * TODO: Register permissions: "assign vocabulary as access voc" (hook)
 * TODO: Use Utils::createFieldInstance() to append the field to node_types,users,osv...
 */


/**
 * Implements hook_node_grants().
 * 
 * Every time a node (or a part of a node) is subject
 * to viewing/updating/deleting this hook is called
 * and we can evaluate the user access and his operations.
 * 
 */
function abt_node_grants($account, $op) {
  $grants = array();
  $usr = user_load($account->uid);
  $lang = !empty($usr->languange) ? $usr->languange : LANGUAGE_NONE;
  $access_map = db_select('abt_map', 'a')->fields('a')->execute();
  while($r = $access_map->fetchAssoc()) {
    // This zero makes sure that every user has update access to unrestricted nodes.
    $grants['abt_'.$r['field_name']] = array(0);
    if(isset($usr->{$r['field_name']})) {  // Current realm is applicable on this user.
      // Get the tids from users field (realm).
      $terms = (!empty($usr->{$r['field_name']}[$lang])) ? $usr->{$r['field_name']}[$lang] : array(); 

      /* Is this operation supported by the realm */
      isset($r['ctrl_'.$op.'_access']) 
        /* Is this realm controlling the requested operation */
        && ($r['ctrl_'.$op.'_access'] == 1) 
          /* Get the children of terms and assign them all to the current realm. */
          && ($grants['abt_'.$r['field_name']] = AbtUtils::taxonomyGetChildrenAll($terms));
    }

  }
  return $grants;
}

/**
 * Implements hook_node_access_records().
 *
 * Writes to node_access table every time  a node gets added / updated. Here we
 * check for reference fields and can see if user has updated/created any access
 * fields - and then we act on that.
 */
function abt_node_access_records($node) {
  $tids = $grants = array();
  $access_map = db_select('abt_map', 'a')->fields('a')->execute();
  
  while($realm = $access_map->fetchAssoc()) {
    if(!isset($node->{$realm['field_name']})) { continue; }
    
    $field_data =& $node->{$realm['field_name']}[$node->language];
    $tids = (!empty($field_data)) ? $field_data : array(array('tid' => 0));
    
    $used_tids = array(); 
    for($i = 0; $i < count($tids); $i++) {
      // node_access table does not allow duplicate nid-gid-realm combo (in our case it's nid-tid-fieldname).
      // Duplicate terms will probably never happen in normal usage but devel-generate module does this 
      // when field cardinality is greater then 1 (there is a debate on wheather this is a bug or not).
      // Anyway, we adress it here and prevent duplicate terms trigger writing to the node_access table.
      if(!in_array($tids[$i]['tid'], $used_tids)) {
        $used_tids[] = $tids[$i]['tid'];
        $grants[] = AbtUtils::grantConstruct(
          $node->nid, 
          'abt_'.$realm['field_name'], 
          $tids[$i]['tid'], 
          $realm['ctrl_view_access'], 
          $realm['ctrl_update_access'], 
          $realm['ctrl_delete_access']
        );
      }
    }
  }
  return $grants;
}


/**
 * Implements hook_form_FORM_ID_alter().
 */
function abt_form_field_ui_field_edit_form_alter(&$form, &$form_state, $form_id) {
  // Make sure we are dealing with a term reference
  if(!isset($form['#field']['type']) XOR $form['#field']['type'] != 'taxonomy_term_reference') {
    return;
  }
  
  $no_perms = (
      !user_access('assign view access control') 
    & !user_access('assign update access control') 
    & !user_access('assign delete access control')
  );
  
  $current = db_select('abt_map', 'a')
    ->fields('a')
    ->condition('field_name', $form['#field']['field_name'])
    ->execute()
    ->fetchAssoc();
  
  $form['abt'] = array(
      '#type' => 'fieldset', 
      '#title' => t('Access by Term'), 
      '#weight' => -1, 
      '#collapsible' => TRUE, 
      '#collapsed' => FALSE,
      '#description' => ($no_perms) ? 
        '<p>'.t('Sorry but you have no permission to assign access control to fields. Talk to your administrator.').'</p>' : 
        '<p>'.t('<em>If you check any or all of these, access for this content type will be controlled by ABT and unauthorized users will have no access to this content type. However, if none are checked, this remains a regular field. Let\'s say you check only "delete" flag. This would mean you want to control the "delete" access with the field. Other two unchecked boxes will result in "access denied".</em>').'</p>'
        .'<p>'.t('<em>Note: by saving these settings, your content permissions will get rebuilt. This is a must if your changes are to take place.</em>').'</p>'
  );
  
  if(user_access('assign view access control')) {
    $form['abt']['abt_enable_view_control'] = array(
      '#type' => 'checkbox',
      '#title' => t('Control "view" access with this field.'),
      '#description' => t('Set this checkbox to control the "<strong>view</strong>" access for the content type <strong>@ct</strong>.', array('@ct' => $form['#instance']['bundle'])),
      '#default_value' => (isset($current['ctrl_view_access']) ? $current['ctrl_view_access'] : 0),
    );
  }
  if(user_access('assign update access control')) {
    $form['abt']['abt_enable_update_control'] = array(
      '#type' => 'checkbox',
      '#title' => t('Control "update" access with this field.'),
      '#description' => t('Set this checkbox to control the "<strong>update</strong>" access for the content type <strong>@ct</strong>.', array('@ct' => $form['#instance']['bundle'])),
      '#default_value' => (isset($current['ctrl_update_access']) ? $current['ctrl_update_access'] : 0),
    );
  }
  if(user_access('assign delete access control')) {  
    $form['abt']['abt_enable_delete_control'] = array(
      '#type' => 'checkbox',
      '#title' => t('Control "delete" access with this field.'),
      '#description' => t('Set this checkbox to control the "<strong>delete</strong>" access for the content type <strong>@ct</strong>.', array('@ct' => $form['#instance']['bundle'])),
      '#default_value' => (isset($current['ctrl_delete_access']) ? $current['ctrl_delete_access'] : 0),
    ); 
  }
  /* For a feature comming up */
  // $form['abt']['assistent'] = array(
  //     '#type' => 'fieldset', 
  //     '#title' => t('Assistent'), 
  //     //'#weight' => -1, 
  //     '#collapsible' => TRUE, 
  //     '#collapsed' => FALSE,
  //     '#description' => '<p>'.t('Create field instances.').'</p>',
  // );
  // 
  // $form['abt']['assistent']['auto_create_instances'] = array(
  //   '#type' => 'checkbox',
  //   '#title' => t('Control "delete" access with this field.'),
  //   '#description' => t('Set this checkbox to create field instances on the fly'),
  //   '#default_value' => (isset($current['ctrl_delete_access']) ? $current['ctrl_delete_access'] : 0),
  // ); 
  // $form['#instance']['entity_type'];
  // $form['#field']['bundles']['node']
  // $form['#field']['bundles']['user']
  
  $form['#submit'][] = 'abt_form_field_ui_field_edit_form_submit';
}

function abt_form_field_ui_field_edit_form_submit($form_data) {
  if(!isset($form_data['abt']['abt_enable_view_control']) && !isset($form_data['abt']['abt_enable_view_control']) && $form_data['abt']['abt_enable_delete_control']) {
    return;
  }
  $field_name = $form_data['#field']['field_name'];
  $ctrl_view_access = user_access('assign view access control') ? (int) $form_data['abt']['abt_enable_view_control']['#checked'] : 0;
  $ctrl_update_access = user_access('assign update access control') ? (int) $form_data['abt']['abt_enable_update_control']['#checked'] : 0;
  $ctrl_delete_access = user_access('assign delete access control') ? (int) $form_data['abt']['abt_enable_delete_control']['#checked'] : 0;
  
  db_delete('abt_map')->condition('field_name', $field_name)->execute();
  
  if($ctrl_view_access + $ctrl_update_access + $ctrl_delete_access > 0) {
    db_insert('abt_map')
      ->fields(array(
        'field_name' => $field_name,  
        'ctrl_view_access' => $ctrl_view_access,
        'ctrl_update_access' => $ctrl_update_access,
        'ctrl_delete_access' => $ctrl_delete_access,
      ))
      ->execute();
  } 
  /* For a feature comming up. */
  // createFieldInstance($field_name, $field_title, $entity_type, $bundle)
  node_access_rebuild();
}

/**
 * Implements hook_form_BASE_FORM_ID_alter().
 * 
 * Here we tell users if a field is beeing used for access control. 
 * Even which ascpect of access control the field is defining (view,update,delete).
 */
function abt_form_node_form_alter(&$form, &$form_state, $form_id) {
  $access_map = db_select('abt_map', 'a')->fields('a')->execute();
  while($realm = $access_map->fetchAssoc()) {
    if(isset($form[$realm['field_name']])) {
      $field =& $form[$realm['field_name']];
      $view = ($realm['ctrl_view_access'] == 1) ? t('view').' ' : '';
      $update = ($realm['ctrl_update_access'] == 1) ? t('update').' ' : '';
      $delete = ($realm['ctrl_delete_access'] == 1) ? t('delete').' ' : '';
      
      $msg = str_replace(' ', ', ', trim($view.$update.$delete));
      $msg = (!empty($msg)) ? ' <em>(Access control enabled for: '.$msg.')</em>' : '';
      
      $field[LANGUAGE_NONE]['#title'] = $field[LANGUAGE_NONE]['#title'].$msg;
    }
  }
}

/**
 * Implements hook_perm().
 */
function abt_permission() {
  return array(
    'assign view access control' => array(
      'title' => t('Assign fields to control node <strong>view</strong> access'),
      'restrict access' => TRUE,
    ),
    'assign update access control' => array(
      'title' => t('Assign fields to control node <strong>update</strong> access'),
      'restrict access' => TRUE,
    ),
    'assign delete access control' => array(
      'title' => t('Assign fields to control node <strong>delete</strong> access'),
      'restrict access' => TRUE,
    ),
  );
}

/**
 * Implements hook_help().
 */
function abt_help($path, $arg) {
  if ($path == 'admin/help#abt') {
    $out = '';
    $out .= '<h3>' . t('About ABT') . '</h3>';
    $out .= '<p>' . t('ABT (Access by Term) is a module that controls node access based on relationship between node-&gt;term&lt;-user where taxonomy terms allow for hierarchical content access control.') . '</p>';
    
    $out .= '<h3>' . t('Installation') . '</h3>';
    $out .= '<p>' . t('Install & enable.') . '</p>';
    
    $out .= '<h3>' . t('Usage') . '</h3>';
    $out .= '<ol>';
    $out .= '<li>' . t('After enabling the module, make sure you set appropriate permissions for your roles.') . '</li>';
    $out .= '<li>' . t('Add some taxonomy terms in the vocabularies you intent to use. Do not forget to think hierarchically. ABT handles access inheritance in such way that parent has equal or greater access then it\'s child.') . '</li>';
    $out .= '<li>' . t('Create fields:');
    $out .= '<ul>';
    $out .= '<li>' . t('Add a "Term reference" field instance to the content type(s) you want to control.') . '</li>';
    $out .= '<li>' . t('Add a "Term reference" field instance to the user.') . '</li>';
    $out .= '</ul>';
    $out .= '<p>' . t('ABT has support for multiple access flags, so you may set the field instances to "unlimited" values, if you need. When editing/adding settings for the field instance, pick the type of access to control by checking any or all of the flags view/update/delete. If you check any of these, access for this content type will be controlled by ABT. If none are checked, this remains a regular field. Let\'s say you check only "delete" flag. This would mean you want to control the "delete" access with the field. Other two unchecked boxes will result in "access denied".').'</p>';
    $out .= '<p>' . t('If your setup requires, you can create any number of different fields (with different vocabularies attached) and have each control one of the flags (view/update/delete). It\'s completely up to you how you set it up. If you ame to use more then one field per content type - It is your responsibility to make sure that there fields controlling are not overlapping (For example: field A and field B are both set to control view-access for content type Articles - this could have unexpected results).') . '</p>';
    $out .= '</li>';
    $out .= '<li>' . t('"Tag" nodes with appropriate access terms.') . '</li>';
    $out .= '<li>' . t('"Tag" users with appropriate access terms.') . '</li>';
    $out .= '</ol>';

    return $out;
  }
}
